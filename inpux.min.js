class Inpux { constructor(e, t) { this.options = this.setOptions(t), this.input = this.setInput(e), this.input && (this.previousValue = this.input.value, this.input.value = this.val(), this.format(!0)) } setOptions(e) { var t, i, n, r, l, s, a, o, p, u, h, c, m, f, d, g, y, $, _, v, b, A, E, L, x, S, U, B, T, M, N, C, O, P, j, Z; (e = "object" == typeof e ? e : {}).timePattern = e.datePattern = null; let R; e.type = ["NUMERAL", "DATE", "TIME", "CUSTOM"].includes(R = String(t = e.type).toUpperCase()) ? R : "CUSTOM"; let k, D, I, V, H, F, W, Y, G, w, K = { NUMERAL: { type: e.type, onBlur: !!(i = e.onBlur) && ("string" == typeof i ? /^(true|false)$/i.test(i) : "boolean" == typeof i && i), emptyToZero: (n = e.emptyToZero) ? "string" == typeof n ? /^(true|false)$/i.test(n) : "boolean" != typeof n || n : "boolean" != typeof n, decimalPlaces: !!(Q(r = e.decimalPlaces) && Math.min(parseInt(r), 100) >= 0) && Math.min(parseInt(r), 100), numeralStyle: ["THOUSAND", "LAKH", "WAN"].includes(k = String(l = e.numeralStyle).toUpperCase()) ? k : "THOUSAND", trailingZero: (s = e.trailingZero) ? "string" == typeof s ? /^(true|false)$/i.test(s) : "boolean" != typeof s || s : "boolean" != typeof s, delimiters: (C = ee(!!(a = e.delimiters) && ("string" == typeof a ? a.split("") : !!Array.isArray(a) && a)), O = [",", "."], "" === (C = 0 == (C = (C || O).slice(0, 2).filter(e => "string" == typeof e).map(e => e.replace(/[0-9-]/g, "").charAt(0))).length ? O : 1 == C.length ? [C[0], C[0]] : C)[1] ? [C[0], O[1]] : C), max: !!Q(o = e.max) && J(o), min: !!Q(p = e.min) && J(p) }, CUSTOM: { type: e.type, onBlur: !!(u = e.onBlur) && ("string" == typeof u ? /^(true|false)$/i.test(u) : "boolean" == typeof u && u), blocks: !!(D = !!(h = e.blocks) && ((P = h, "number" == typeof P) ? [h] : !!Array.isArray(h) && h.length > 0 && h)) && (Z = (j = D, !!j && j.map(e => e ? "number" == typeof e ? parseInt(e) : "string" == typeof e ? isNaN(parseInt(e)) ? 0 : parseInt(e) : 0 : 0)), Z.map(e => Math.abs(e))), onlyNumbers: !!(c = e.onlyNumbers) && ("string" == typeof c ? /^(true|false)$/i.test(c) : "boolean" == typeof c && c), leadingZero: (m = e.leadingZero) ? "string" == typeof m ? /^(true|false)$/i.test(m) : "boolean" != typeof m || m : "boolean" != typeof m, delimiters: ee(!!(f = e.delimiters) && ("string" == typeof f ? f.split("") : !!Array.isArray(f) && f)) || [""], contained: !!(d = e.contained) && ("string" == typeof d ? /^(true|false)$/i.test(d) : "boolean" == typeof d && d), max: Q(g = e.max) ? [J(g)] : !!Array.isArray(g) && X(g).length > 0 && X(g), min: Q(y = e.min) ? [J(y)] : !!Array.isArray(y) && X(y).length > 0 && X(y) }, TIME: { contained: !0, onlyNumbers: !0, leadingZero: !0, type: e.type, onBlur: !!($ = e.onBlur) && ("string" == typeof $ ? /^(true|false)$/i.test($) : "boolean" == typeof $ && $), pattern: function (t) { let i = ["H", "M", "S"], n = "string" == typeof t ? t.split("") : Array.isArray(t) ? t : i, r = []; for (let l of n) r.includes(l) || r.includes(l.toUpperCase()) || r.push(l); return n = r.filter(e => i.includes(String(e).toUpperCase())), e.timePattern = n, n }(e.pattern), delimiters: ee((_ = e.delimiters) ? "string" == typeof _ ? _.split("") : Array.isArray(_) ? _ : [":"] : [":"]) || [":"], blocks: (v = e.timePattern).map(e => 2), max: (b = e.timePattern, A = e.max, I = { H: [0, 23] }, V = b.map(e => I[e.toUpperCase()] || [0, 59]), A = (A = Q(A) ? [parseInt(A)] : Array.isArray(A) ? A : []).slice(0, V.length), V.map((e, t) => A[t] ? Math.min(Math.max(e[0], A[t]), e[1]) : e[1])), min: (E = e.timePattern, L = e.min, H = { H: [0, 23] }, F = E.map(e => H[e.toUpperCase()] || [0, 59]), L = (L = Q(L) ? [parseInt(L)] : Array.isArray(L) ? L : []).slice(0, F.length), F.map((e, t) => L[t] ? Math.min(Math.max(e[0], L[t]), e[1]) : e[0])) }, DATE: { contained: !0, onlyNumbers: !0, leadingZero: !0, type: e.type, onBlur: !!(x = e.onBlur) && ("string" == typeof x ? /^(true|false)$/i.test(x) : "boolean" == typeof x && x), pattern: function (t) { let i = ["M", "D", "Y"], n = "string" == typeof t ? t.split("") : Array.isArray(t) ? t : i, r = []; for (let l of n) r.includes(l) || r.includes(l.toUpperCase()) || r.push(l); return n = r.filter(e => i.includes(String(e).toUpperCase())), e.datePattern = n, n }(e.pattern), delimiters: ee((S = e.delimiters) ? "string" == typeof S ? S.split("") : Array.isArray(S) ? S : ["/"] : ["/"]) || ["/"], blocks: (U = e.datePattern).map(e => "Y" === e ? 4 : 2), max: (B = e.datePattern, T = e.max, W = { Y: [1, 9999], M: [1, 12] }, Y = B.map(e => W[e.toUpperCase()] || [1, 31]), T = (T = Q(T) ? [parseInt(T)] : Array.isArray(T) ? T : []).slice(0, Y.length), Y.map((e, t) => T[t] ? Math.min(Math.max(e[0], parseInt(T[t])), e[1]) : e[1])), min: (M = e.datePattern, N = e.min, G = { Y: [1, 9999], M: [1, 12] }, w = M.map(e => G[e.toUpperCase()] || [1, 31]), N = (N = Q(N) ? [parseInt(N)] : Array.isArray(N) ? N : []).slice(0, w.length), w.map((e, t) => N[t] ? Math.min(Math.max(e[0], parseInt(N[t])), e[1]) : e[0])) } }, q = K[e.type]; for (let z in q) !1 === q[z] && delete q[z]; return q; function J(e) { return e ? e.toLocaleString("en-US", { useGrouping: !1 }) : e } function Q(e) { let t = J(e); return t = !!t && t.replace(/[\.]/g, ""), /^-?\d+$/.test(t) && !isNaN(Number(e)) } function X(e) { return e.map(e => { let t = "number" == typeof e ? Number.isInteger(e) ? e : Math.floor(e) : !!("string" == typeof e && Q(e)) && e; return !!Q(t) && J(t) }) } function ee(e) { return !!e && e.map(e => e ? "string" == typeof e ? e : e.toString : "") } } setInput(e) { var t; if (e = (t = e) ? "string" == typeof t ? document.querySelector(t) : e instanceof HTMLInputElement ? t : null : null) return e.addEventListener("input", this.handleInputEventListener), e.addEventListener("focus", this.handleFocusEventListener), e.addEventListener("blur", this.handleBlurEventListener), e } handleInputEventListener = e => { if (this.options.onBlur) this.input.value = this.val(), this.adjustValue(); else { let t = this.input.value, i = this.input.selectionStart; this.input.value = this.val(), this.adjustValue(), this.format(), this.input.value == this.previousValue && "deleteContentBackward" == e.inputType && i--, this.previousValue = this.input.value; let n = i + (this.input.value.length - t.length); if (this.input.setSelectionRange) this.input.setSelectionRange(n, n); else if (this.input.createTextRange) { let r = this.input.createTextRange(); r.collapse(!0), r.moveEnd("character", n), r.moveStart("character", n), r.select() } } }; handleBlurEventListener = () => { this.options.onBlur ? (this.format(!0), this.previousValue = this.input.value) : (this.input.value = this.val(), this.adjustValue(), this.format(!0), this.previousValue = this.input.value) }; handleFocusEventListener = () => { this.options.onBlur && (this.input.value = this.val()) }; format(e) { let t = this.options, i = this.input.value, n = t.onlyNumbers, r = t.decimalPlaces, l = t.emptyToZero, s = t.trailingZero, a = t.leadingZero, o = t.delimiters, p = t.blocks, u = t.max, h = t.min, c = t.pattern, m = "NUMERAL" === t.type, f = "DATE" === t.type; i = m && "-" == i && e ? "" : i, i = String(n && !p && g(h) && i.length > 0 && e && Number(i) <= Number(h) ? h : i), i = String(n && !p && g(u) && i.length > 0 && e && Number(i) >= Number(u) ? u : i); let d = m ? function i(n) { var a, p; if (0 === n.length) { if (!l || !e) return [""]; n = h && Number(h) > 0 ? h : "0" } let c = !e && n.endsWith(`${o[1]}`) && o[1] ? o[1] : "", m = { LAKH: /\B(?=(?:(\d\d)+(\d)(?!\d))+(?!\d))/g, THOUSAND: /\B(?=(\d{3})+(?!\d))/g, WAN: /\B(?=(\d{4})+(?!\d))/g }[t.numeralStyle.toUpperCase()], f = r && e ? Number(n.replace(o[1], ".")).toFixed(r) : Number(n.replace(o[1], ".")); n = e ? n.replace(/^(-?)0+(?=[\d])/g, "$1").replace(`-${o[1]}`, `-0${o[1]}`).replace(RegExp(`^\\${o[1]}`), `0${o[1]}`) : n.replace(/^(-?)0+(?=[\d])/g, "$1"), n = f <= Number(h) && e ? h.replace(".", o[1]) : n, n = f >= Number(u) && e ? u.replace(".", o[1]) : n, 0 == f && n.includes("-") && e && (n = n.replace("-", "")); let d = n.split(o[1]); d[0] = d[0].replace(m, o[0]), d[1] = d[1] ? o[1] + (e && g(r) && s ? (a = d[1].slice(0, String(r)), p = r, a.length < p ? a + "0".repeat(p - a.length) : a) : !e && g(r) ? d[1].slice(0, String(r)) : d[1]) : e && g(r) && s ? `${o[1]}${"0".repeat(r)}` : ""; let y = e ? d.join("").replace(/^-0$/, "0") : d.join(""); return y.startsWith(`${o[1]}`) && e ? ["0" + y] : [y + c] }(i) : t.blocks ? function t(i) { let r = [], l = 0; for (; i.length > 0;) { let s = p[l % p.length], o = i.slice(0, s); if (n && e) { let m = !!Array.isArray(h) && h[l % h.length], d = !!Array.isArray(u) && u[l % u.length]; o = String(g(m) && Number(o) <= Number(m) ? m : o), o = String(g(d) && Number(o) >= Number(d) ? d : o), o = a ? y(o, s) : o } o.length > 0 && (r.push(o), i = i.slice(s)), l++ } if (f && e) { let $ = c.indexOf("m") > -1 ? c.indexOf("m") : c.indexOf("M"), _ = c.indexOf("d") > -1 ? c.indexOf("d") : c.indexOf("D"), v = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][r[$] - 1] || 31; r[_] && r[$] && (r[_] = y(Math.min(r[_], v), 2)) } return r }(i) : [i]; function g(e) { var t; let i = (t = e) ? t.toLocaleString("en-US", { useGrouping: !1 }) : t; return i = !!i && i.replace(/[\.]/g, ""), /^-?\d+$/.test(i) && !isNaN(Number(e)) } function y(e, t) { return String(e).padStart(t, "0") } this.input.value = "" + function e(t) { let i = 0, n = t.map((e, n) => { let r = o[i]; return i = (i + 1) % o.length, n === t.length - 1 ? e : e + r }).join(""); return n }(d, o) } val(e) { var t; let i = this.options, n = this.input.value, r = this.options.blocks, l = this.options.contained, s = ("NUMERAL" === i.type ? [i.delimiters[0]] : i.delimiters).map(e => e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")); return e ? n : l && r ? n.replace(RegExp(s.join("|"), "gi"), "").slice(0, (t = i.blocks, t.reduce((e, t) => e + t, 0))) : n.replace(RegExp(s.join("|"), "gi"), "") } adjustValue() { let e = "", t = this.options, i = this.input.value, n = t.delimiters, r = t.onlyNumbers, l = "NUMERAL" === t.type, s = this.input.selectionStart, a = l ? [n[0]].map(e => e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")) : n.map(e => e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")); if (i = i.replace(RegExp(a.join("|"), "gi"), ""), l) { var o, p, u, h; e += i.split("-").length > 1 ? "-" : ""; let c, m = (o = i, p = n[1], c = RegExp(u ? `\\${p}` : `(\\${p}(?=[^${p}]*\\${p}))`, "g"), (u ? o.replace(c, function (e, t, i) { return i.indexOf(e) === t ? e : "" }) : o.replace(c, "")).replace(RegExp(`[^\\d${p}]`, "g"), "")).split(n[1]); m[0] = m[0].length > 0 ? String((h = m[0], h.toLocaleString("fullwide", { useGrouping: !1 }))) : "", m[1] = m.length > 1 ? n[1] + m[1] : "", i = m.join("") } i = r ? i.replace(/[\D]/g, "") : i, this.input.value = e + i, this.input.setSelectionRange(s, s) } destroy() { this.input.value = this.val(), this.input.removeEventListener("input", this.handleInputEventListener), this.input.removeEventListener("focus", this.handleFocusEventListener), this.input.removeEventListener("blur", this.handleBlurEventListener) } groups() { let e = this.options.delimiters, t = [this.val(!0)]; return e.forEach(e => { t = t.flatMap(t => t.split(e)) }), t = t.filter(e => "" !== e) } }
console.log("foi")
